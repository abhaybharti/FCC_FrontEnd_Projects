{"ast":null,"code":"import _objectSpread from \"E:\\\\Work\\\\Projects\\\\FCC_FrontEnd_Projects\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport * as types from \"../types\";\nimport calculate from \"../../utils/calculate\";\nvar initialState = {\n  expression: \"\",\n  total: 0\n};\n\nfunction setExpression(_ref, action) {\n  var expression = _ref.expression,\n      total = _ref.total;\n\n  if (/[\\d]*[-+%*/.]$/.exec(expression) && /[-+%*/.]/.exec(action.payload)) {\n    console.log(\"b\", expression);\n    expression = expression.slice(0, expression.length - 1);\n    console.log(\"a\", expression);\n  }\n\n  switch (action.type) {\n    case types.SET_EXPRESSION:\n      if ([\"+\", \"/\", \"*\", \"%\"].includes(action.payload) && !expression) {\n        return \"\".concat(total).concat(action.payload);\n      }\n\n      return \"\".concat(!expression && total ? total : \"\").concat(expression + action.payload);\n\n    default:\n      return expression;\n  }\n}\n\nexport default (function () {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case types.SET_EXPRESSION:\n      console.log(\"inside reducers->calculateReducer : types.SET_EXPRESSION\");\n      var expression = setExpression(state, action);\n      return _objectSpread({}, state, {\n        expression: expression,\n        total: calculate(expression) || state.total\n      });\n\n    case types.CLEAR_EXPRESSION:\n      console.log(\"inside reducers->calculateReducer : types.CLEAR_EXPRESSION\");\n      return _objectSpread({}, state, {\n        expression: \"\",\n        total: 0\n      });\n\n    case types.DELETE_LAST_EXPRESSION_ENTRY:\n      console.log(\"inside reducers->calculateReducer : DELETE_LAST_EXPRESSION_ENTRY\");\n      var exp = state.expression;\n      exp = exp.split(\"\").slice(0, exp.length - 1).join(\"\");\n      return _objectSpread({}, state, {\n        expression: exp,\n        total: calculate(exp)\n      });\n\n    case types.EVALUATE_EXPRESSION:\n      console.log(\"inside reducers->calculateReducer : EVALUATE_EXPRESSION\");\n      return _objectSpread({}, state, {\n        expression: \"\",\n        total: calculate(state.expression) || state.expression || state.total\n      });\n\n    case types.SQUARE:\n      console.log(\"inside reducers->calculateReducer : SQUARE\");\n      return _objectSpread({}, state, {\n        expression: \"\",\n        total: state.expression * state.expression\n      });\n\n    case types.SQUARE_ROOT:\n      console.log(\"inside reducers->calculateReducer : SQUARE_ROOT\");\n      return _objectSpread({}, state, {\n        expression: \"\",\n        total: Math.sqrt(state.expression)\n      });\n\n    default:\n      return state;\n  }\n});","map":{"version":3,"sources":["E:\\Work\\Projects\\FCC_FrontEnd_Projects\\src\\store\\reducers\\calculateReducer.js"],"names":["types","calculate","initialState","expression","total","setExpression","action","exec","payload","console","log","slice","length","type","SET_EXPRESSION","includes","state","CLEAR_EXPRESSION","DELETE_LAST_EXPRESSION_ENTRY","exp","split","join","EVALUATE_EXPRESSION","SQUARE","SQUARE_ROOT","Math","sqrt"],"mappings":"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","sourcesContent":["import * as types from \"../types\";\nimport calculate from \"../../utils/calculate\";\n\nlet initialState = {\n  expression: \"\",\n  total: 0\n};\n\nfunction setExpression({ expression, total }, action) {\n  if (/[\\d]*[-+%*/.]$/.exec(expression) && /[-+%*/.]/.exec(action.payload)) {\n    console.log(\"b\", expression);\n    expression = expression.slice(0, expression.length - 1);\n    console.log(\"a\", expression);\n  }\n\n  switch (action.type) {\n    case types.SET_EXPRESSION:\n      if ([\"+\", \"/\", \"*\", \"%\"].includes(action.payload) && !expression) {\n        return `${total}${action.payload}`;\n      }\n      return `${!expression && total ? total : \"\"}${expression +\n        action.payload}`;\n    default:\n      return expression;\n  }\n}\n\nexport default (state = initialState, action) => {\n  switch (action.type) {\n    case types.SET_EXPRESSION:\n      console.log(\"inside reducers->calculateReducer : types.SET_EXPRESSION\");\n      let expression = setExpression(state, action);\n      return {\n        ...state,\n        expression,\n        total: calculate(expression) || state.total\n      };\n    case types.CLEAR_EXPRESSION:\n    console.log(\"inside reducers->calculateReducer : types.CLEAR_EXPRESSION\");\n      return {\n        ...state,\n        expression: \"\",\n        total: 0\n      };\n    case types.DELETE_LAST_EXPRESSION_ENTRY:\n    console.log(\"inside reducers->calculateReducer : DELETE_LAST_EXPRESSION_ENTRY\");\n      let exp = state.expression;\n      exp = exp\n        .split(\"\")\n        .slice(0, exp.length - 1)\n        .join(\"\");\n      return {\n        ...state,\n        expression: exp,\n        total: calculate(exp)\n      };\n    case types.EVALUATE_EXPRESSION:\n    console.log(\"inside reducers->calculateReducer : EVALUATE_EXPRESSION\");\n      return {\n        ...state,\n        expression: \"\",\n        total: calculate(state.expression) || state.expression || state.total\n      };\n    case types.SQUARE:\n    console.log(\"inside reducers->calculateReducer : SQUARE\");\n      return {\n        ...state,\n        expression: \"\",\n        total: state.expression * state.expression\n      };\n    case types.SQUARE_ROOT:\n    console.log(\"inside reducers->calculateReducer : SQUARE_ROOT\");\n      return {\n        ...state,\n        expression: \"\",\n        total: Math.sqrt(state.expression)\n      };\n    default:\n      return state;\n  }\n};"]},"metadata":{},"sourceType":"module"}